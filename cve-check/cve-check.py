#!/usr/bin/env python3
"""CVE Pattern Checker for h-cli Asimov Firewall.

Scans the NVD for vulnerabilities affecting the h-cli stack, then hands
all CVEs to Claude in a single batch call with WebSearch enabled so it
can research actual exploits and propose meaningful denylist patterns.

Approved patterns are written to a staging file in data/ — the user
manually appends them to blocked-patterns.txt after review.

Usage:
    docker compose --profile tools run -it --rm cve-check
    docker compose --profile tools run --rm cve-check --list
    docker compose --profile tools run --rm cve-check --dry-run

No external dependencies — stdlib only.
"""

import argparse
import json
import os
import subprocess
import sys
import time
import urllib.error
import urllib.parse
import urllib.request
from datetime import datetime, timedelta, timezone
from pathlib import Path

# ── Config ──────────────────────────────────────────────────────────────

APP_DIR = Path("/app")
BLOCKED_PATTERNS_FILE = APP_DIR / "blocked-patterns.txt"
SKILLS_DIRS = [
    APP_DIR / "skills" / "public",
    APP_DIR / "skills" / "private",
]
DATA_DIR = APP_DIR / "data"
CHECKPOINT_FILE = DATA_DIR / "cve-checkpoint.json"
STAGING_FILE = DATA_DIR / "cve-proposed-patterns.txt"

NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"

BASE_STACK = [
    "linux kernel",
    "ubuntu",
    "python",
    "docker",
    "redis",
    "grafana",
    "timescaledb",
    "postgresql",
    "node.js",
    "claude",
    "qdrant",
]

KEYWORD_BLOCKLIST = {
    "stats", "statistics", "tokens", "cost", "usage", "spending",
    "expensive", "cheap", "metrics", "dashboard", "how much", "budget",
    "device", "interface", "cable", "ip address", "inventory",
    "lab", "topology", "node", "console",
    "chart", "graph", "image", "panel", "picture", "png", "render",
    "screenshot", "show", "show me", "send me", "monitoring",
    "router", "telnet",
}

MAX_DAYS_PER_QUERY = 120
CHECKPOINT_VERSION = 1

NVD_RATE_DELAY_NO_KEY = 6.5
NVD_RATE_DELAY_WITH_KEY = 0.7

# ── Hardcoded System Context (immutable) ────────────────────────────────
# Baked into the Docker image. The analysis model cannot modify this.

SYSTEM_CONTEXT = """\
h-cli is a natural-language infrastructure management system. A user sends
messages via Telegram, which are dispatched to Claude Code running inside a
Docker container. Claude executes commands on a ParrotOS-based core container
via MCP (Model Context Protocol).

ARCHITECTURE:
- telegram-bot: receives user messages, queues to Redis
- claude-code: dispatches tasks to Claude CLI, runs firewall proxy
- core: ParrotOS container with network/sysadmin tools, executes commands
- redis: message queue and session store
- timescaledb + grafana: monitoring stack (optional)
- qdrant: vector DB for long-term memory (optional)

ASIMOV FIREWALL (what this tool feeds):
The firewall is an MCP proxy (firewall.py) between claude-code and core.
It has two layers:
  Layer 1 — Pattern denylist (blocked-patterns.txt): deterministic,
    zero-latency substring matching against every command. If any pattern
    matches (case-insensitive), the command is blocked immediately.
  Layer 2 — Haiku gate (optional): semantic analysis by a small LLM for
    commands that pass Layer 1.
This tool maintains Layer 1 only.

LEGITIMATE COMMANDS INSIDE CORE (do NOT block these):
  nmap, tcpdump, traceroute, mtr, ping, ss, ip, iptables (scoped sudo)
  curl, wget, dig, nslookup, whois, ssh, scp, netstat
  python3, cat, ls, grep, find, apt list, systemctl status
  redis-cli (connecting to own Redis), psql (querying metrics)

WHAT TO BLOCK (patterns that indicate exploitation):
  - Reverse shell techniques (already covered, but new variants emerge)
  - Container escape commands (nsenter, mounting docker.sock, cgroup abuse)
  - Privilege escalation via tool flags (sudo bypass, nmap --interactive)
  - Data exfiltration channels (DNS tunneling, curl to external with data)
  - Tool-specific CVE exploitation (redis MODULE LOAD, docker --privileged)
  - Destructive operations (rm -rf /, disk wiping, kernel manipulation)

PATTERN FORMAT:
  Each pattern is a case-insensitive substring. When a command contains the
  pattern anywhere in it, the command is blocked. Patterns must be specific
  enough to avoid false positives on the legitimate commands listed above.
  Example: "redis-cli debug set-active-expire" blocks that specific abuse
  without blocking normal "redis-cli get mykey" operations.\
"""


# ── Checkpoint ──────────────────────────────────────────────────────────

def load_checkpoint() -> dict:
    if CHECKPOINT_FILE.exists():
        with open(CHECKPOINT_FILE) as f:
            return json.load(f)
    return {
        "last_scan_date": None,
        "processed_cve_ids": [],
        "last_run": None,
        "version": CHECKPOINT_VERSION,
    }


def save_checkpoint(checkpoint: dict) -> None:
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    checkpoint["last_run"] = datetime.now(timezone.utc).isoformat()
    with open(CHECKPOINT_FILE, "w") as f:
        json.dump(checkpoint, f, indent=2)


# ── Technology List ─────────────────────────────────────────────────────

def extract_skills_keywords() -> list[str]:
    """Parse keywords from skills YAML headers, filtering non-tech terms."""
    keywords = set()
    for skills_dir in SKILLS_DIRS:
        if not skills_dir.is_dir():
            continue
        for fpath in sorted(skills_dir.glob("*.md")):
            try:
                content = fpath.read_text()
            except OSError:
                continue
            if not content.startswith("---"):
                continue
            end = content.find("---", 3)
            if end == -1:
                continue
            header = content[3:end]
            for line in header.splitlines():
                line = line.strip()
                if line.lower().startswith("keywords:"):
                    kw_str = line.split(":", 1)[1].strip()
                    for kw in kw_str.split(","):
                        kw = kw.strip().lower()
                        if kw and kw not in KEYWORD_BLOCKLIST:
                            keywords.add(kw)
    return sorted(keywords)


def build_tech_list() -> list[str]:
    """Combine base stack with skills-derived technologies."""
    techs = list(BASE_STACK)
    skills_kws = extract_skills_keywords()
    for kw in skills_kws:
        if kw not in techs:
            techs.append(kw)
    return techs


# ── NVD Queries ─────────────────────────────────────────────────────────

def _nvd_date_fmt(dt: datetime) -> str:
    return dt.strftime("%Y-%m-%dT%H:%M:%S.000")


def _get_rate_delay() -> float:
    if os.environ.get("NVD_API_KEY"):
        return NVD_RATE_DELAY_WITH_KEY
    return NVD_RATE_DELAY_NO_KEY


def query_nvd(keyword: str, start_date: datetime, end_date: datetime) -> list[dict]:
    """Query NVD for CRITICAL + HIGH CVEs matching a keyword in a date range."""
    api_key = os.environ.get("NVD_API_KEY")
    rate_delay = _get_rate_delay()
    results = []

    for severity in ["CRITICAL", "HIGH"]:
        params = {
            "keywordSearch": keyword,
            "cvssV3Severity": severity,
            "pubStartDate": _nvd_date_fmt(start_date),
            "pubEndDate": _nvd_date_fmt(end_date),
        }
        url = f"{NVD_API_URL}?{urllib.parse.urlencode(params)}"

        headers = {}
        if api_key:
            headers["apiKey"] = api_key

        try:
            req = urllib.request.Request(url, headers=headers)
            with urllib.request.urlopen(req, timeout=30) as resp:
                data = json.loads(resp.read().decode())

            for vuln in data.get("vulnerabilities", []):
                cve_data = vuln.get("cve", {})
                results.append(cve_data)

        except (urllib.error.URLError, urllib.error.HTTPError, json.JSONDecodeError) as e:
            print(f"  Warning: NVD query failed for '{keyword}' ({severity}): {e}")

        time.sleep(rate_delay)

    return results


def chunk_date_range(start: datetime, end: datetime) -> list[tuple[datetime, datetime]]:
    chunks = []
    current = start
    while current < end:
        chunk_end = min(current + timedelta(days=MAX_DAYS_PER_QUERY), end)
        chunks.append((current, chunk_end))
        current = chunk_end
    return chunks


def extract_cve_info(cve_data: dict) -> tuple[str, str, float]:
    cve_id = cve_data.get("id", "UNKNOWN")

    description = ""
    for desc in cve_data.get("descriptions", []):
        if desc.get("lang") == "en":
            description = desc.get("value", "")
            break
    if not description:
        descs = cve_data.get("descriptions", [])
        if descs:
            description = descs[0].get("value", "")

    score = 0.0
    metrics = cve_data.get("metrics", {})
    for key in ["cvssMetricV31", "cvssMetricV30"]:
        metric_list = metrics.get(key, [])
        if metric_list:
            cvss = metric_list[0].get("cvssData", {})
            score = cvss.get("baseScore", 0.0)
            break

    return cve_id, description, score


# ── Claude Batch Analysis ──────────────────────────────────────────────

def build_analysis_prompt(cve_summaries: list[dict], current_patterns: str) -> str:
    cve_block = ""
    for cve in cve_summaries:
        cve_block += (
            f"\n{cve['id']} | CVSS {cve['score']} | {cve['keyword']}\n"
            f"  {cve['description'][:200]}\n"
        )

    return (
        "You are a security analyst reviewing CVEs for a command-line firewall.\n"
        "\n"
        "## System Context\n"
        f"{SYSTEM_CONTEXT}\n"
        "\n"
        f"There are {len(cve_summaries)} new CVEs to review. Most will NOT need patterns\n"
        "(memory bugs, web-only, library-level issues). Your job is to find the ones\n"
        "that DO have command-line exploitation vectors relevant to this system.\n"
        "\n"
        "## Step 1: Triage\n"
        "Scan all CVEs below. Identify any that could involve:\n"
        "- Specific CLI commands or flags that trigger the vulnerability\n"
        "- Tool abuse (redis-cli, docker, curl, nmap, etc.)\n"
        "- Shell escape sequences or injection patterns\n"
        "- Configuration file manipulation via command line\n"
        "- Container escape or privilege escalation techniques\n"
        "\n"
        "## Step 2: Research\n"
        "For each promising CVE, use WebSearch to find:\n"
        "- Proof-of-concept exploits with actual commands\n"
        "- Security advisories with technical details\n"
        "- Blog posts or writeups showing exploitation steps\n"
        "\n"
        "## Step 3: Propose patterns\n"
        "For CVEs with real CLI vectors, propose specific substring patterns.\n"
        "Remember: patterns are case-insensitive substrings matched against the\n"
        "full command string. They must be specific enough to avoid blocking the\n"
        "legitimate commands listed in the system context above.\n"
        "\n"
        "## Current blocked patterns file:\n"
        "```\n"
        f"{current_patterns}\n"
        "```\n"
        "\n"
        "## CVEs to review:\n"
        f"{cve_block}\n"
        "\n"
        "## Output format\n"
        "Output ONLY a JSON array. Each element:\n"
        '{"cve_id": "CVE-...", "score": 9.8, "keyword": "redis", "patterns": ["pattern1", "pattern2"], "reason": "brief explanation"}\n'
        "\n"
        "If NO CVEs need patterns, output: []\n"
        "Do NOT include CVEs that don't need patterns.\n"
        "Output raw JSON only — no markdown fences, no commentary."
    )


def run_claude_analysis(prompt: str) -> str | None:
    print("Running Claude analysis with WebSearch (this may take a few minutes)...")

    try:
        result = subprocess.run(
            [
                "claude", "-p",
                "--output-format", "text",
                "--model", "sonnet",
                "--dangerously-skip-permissions",
                "--allowedTools", "WebSearch",
                "--no-session-persistence",
                "--disable-slash-commands",
                "--", prompt,
            ],
            capture_output=True,
            text=True,
            timeout=600,
        )
        if result.returncode != 0:
            print(f"  Warning: Claude analysis failed: {result.stderr.strip()}")
            return None
        return result.stdout.strip()
    except FileNotFoundError:
        print("Error: 'claude' CLI not found in container.", file=sys.stderr)
        sys.exit(1)
    except subprocess.TimeoutExpired:
        print("  Warning: Claude analysis timed out (10 min limit)")
        return None


def parse_batch_output(output: str) -> list[dict]:
    if not output:
        return []

    text = output.strip()
    if text.startswith("```"):
        lines = text.splitlines()
        lines = [l for l in lines if not l.startswith("```")]
        text = "\n".join(lines).strip()

    try:
        proposals = json.loads(text)
        if not isinstance(proposals, list):
            return []
        return proposals
    except json.JSONDecodeError:
        print(f"  Warning: Could not parse Claude output as JSON")
        print(f"  Raw output:\n{output[:500]}")
        return []


# ── User Interaction ────────────────────────────────────────────────────

def prompt_user(proposal: dict) -> tuple[str, list[str]]:
    cve_id = proposal.get("cve_id", "UNKNOWN")
    score = proposal.get("score", 0.0)
    keyword = proposal.get("keyword", "")
    patterns = proposal.get("patterns", [])
    reason = proposal.get("reason", "")

    sep = "=" * 70
    print(f"\n{sep}")
    print(f"  {cve_id}  (CVSS {score}, {keyword})")
    print(f"{sep}")
    if reason:
        print(f"\n  {reason}")
    print("\n  Proposed patterns:")
    for i, p in enumerate(patterns, 1):
        print(f"    {i}. {p}")
    print()

    while True:
        choice = input("  [a]pprove / [s]kip / [e]dit / [q]uit > ").strip().lower()
        if choice == "a":
            return "approve", patterns
        elif choice == "s":
            return "skip", []
        elif choice == "q":
            return "quit", []
        elif choice == "e":
            print("  Enter patterns (one per line, empty line to finish):")
            edited = []
            while True:
                line = input("    > ").strip()
                if not line:
                    break
                edited.append(line)
            if edited:
                return "approve", edited
            print("  No patterns entered, skipping.")
            return "skip", []
        else:
            print("  Invalid choice. Use a/s/e/q.")


# ── File Operations ─────────────────────────────────────────────────────

def append_staging(cve_id: str, score: float, keyword: str,
                   patterns: list[str]) -> None:
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    header = f"# -- {cve_id} ({score}, {keyword}) "
    header = header + "-" * max(1, 65 - len(header))

    with open(STAGING_FILE, "a") as f:
        f.write(f"\n{header}\n")
        for p in patterns:
            f.write(f"{p}\n")

    print(f"  + {len(patterns)} pattern(s) written to staging file")


# ── Main ────────────────────────────────────────────────────────────────

def main():
    parser = argparse.ArgumentParser(description="CVE Pattern Checker for h-cli firewall")
    parser.add_argument("--list", action="store_true", help="Show technology list and exit")
    parser.add_argument("--dry-run", action="store_true", help="Query + analyze but don't write files")
    args = parser.parse_args()

    tech_list = build_tech_list()

    if args.list:
        print("Technology list for CVE scanning:\n")
        print("Base stack:")
        for t in BASE_STACK:
            print(f"  - {t}")
        skills_kws = extract_skills_keywords()
        if skills_kws:
            print("\nFrom skills:")
            for t in skills_kws:
                marker = " (already in base)" if t in BASE_STACK else ""
                print(f"  - {t}{marker}")
        print(f"\nTotal unique technologies: {len(tech_list)}")
        return

    # Load state
    checkpoint = load_checkpoint()
    processed = set(checkpoint.get("processed_cve_ids", []))
    current_patterns = BLOCKED_PATTERNS_FILE.read_text() if BLOCKED_PATTERNS_FILE.exists() else ""

    # Determine date range
    now = datetime.now(timezone.utc)
    if checkpoint.get("last_scan_date"):
        start_date = datetime.fromisoformat(checkpoint["last_scan_date"])
        print(f"Resuming from checkpoint: {start_date.date()}")
    else:
        start_date = now - timedelta(days=MAX_DAYS_PER_QUERY)
        print(f"First run: scanning last {MAX_DAYS_PER_QUERY} days")

    end_date = now
    date_chunks = chunk_date_range(start_date, end_date)

    has_api_key = bool(os.environ.get("NVD_API_KEY"))
    rate_info = "with API key" if has_api_key else "without API key (slower)"
    print(f"Rate limiting: {rate_info}")

    if args.dry_run:
        print("DRY RUN -- no files will be modified\n")
    else:
        print()

    # Collect all CVEs
    all_cves = {}
    print(f"Querying NVD for {len(tech_list)} technologies...")
    for i, keyword in enumerate(tech_list, 1):
        print(f"  [{i}/{len(tech_list)}] {keyword}", end="", flush=True)
        keyword_cves = []
        for chunk_start, chunk_end in date_chunks:
            results = query_nvd(keyword, chunk_start, chunk_end)
            keyword_cves.extend(results)
        new_count = 0
        for cve_data in keyword_cves:
            cve_id = cve_data.get("id", "")
            if cve_id and cve_id not in processed and cve_id not in all_cves:
                all_cves[cve_id] = (cve_data, keyword)
                new_count += 1
        print(f" -- {len(keyword_cves)} found, {new_count} new")

    if not all_cves:
        print("\nNo new CVEs to process.")
        checkpoint["last_scan_date"] = end_date.isoformat()
        if not args.dry_run:
            save_checkpoint(checkpoint)
        return

    # Build summaries for Claude
    cve_summaries = []
    for cve_id, (cve_data, keyword) in sorted(all_cves.items()):
        _, description, score = extract_cve_info(cve_data)
        cve_summaries.append({
            "id": cve_id,
            "description": description,
            "score": score,
            "keyword": keyword,
        })

    print(f"\n{len(cve_summaries)} new CVE(s) to analyze.\n")

    # Single Claude call with WebSearch
    prompt = build_analysis_prompt(cve_summaries, current_patterns)
    output = run_claude_analysis(prompt)
    proposals = parse_batch_output(output)

    if not proposals:
        print("Claude found no CVEs requiring new patterns.")
    else:
        print(f"\nClaude proposed patterns for {len(proposals)} CVE(s).\n")

    # Mark all CVEs as processed
    all_cve_ids = {s["id"] for s in cve_summaries}

    if args.dry_run:
        for p in proposals:
            print(f"  DRY RUN -- {p['cve_id']} ({p.get('score', '?')}, {p.get('keyword', '?')}):")
            for pat in p.get("patterns", []):
                print(f"    {pat}")
            if p.get("reason"):
                print(f"    Reason: {p['reason']}")
        print(f"\nDone (dry run). {len(proposals)} proposal(s), {len(all_cve_ids)} CVE(s) scanned.")
        return

    # Interactive approval
    approved_count = 0
    for proposal in proposals:
        action, final_patterns = prompt_user(proposal)

        if action == "quit":
            print("\nQuitting. Progress saved.")
            processed.update(all_cve_ids)
            checkpoint["processed_cve_ids"] = sorted(processed)
            checkpoint["last_scan_date"] = end_date.isoformat()
            save_checkpoint(checkpoint)
            return
        elif action == "approve" and final_patterns:
            append_staging(
                proposal.get("cve_id", "UNKNOWN"),
                proposal.get("score", 0.0),
                proposal.get("keyword", ""),
                final_patterns,
            )
            approved_count += 1

    # Save checkpoint
    processed.update(all_cve_ids)
    checkpoint["processed_cve_ids"] = sorted(processed)
    checkpoint["last_scan_date"] = end_date.isoformat()
    save_checkpoint(checkpoint)

    print(f"\nDone. Approved: {approved_count}, Proposals: {len(proposals)}, CVEs scanned: {len(all_cve_ids)}")
    if approved_count > 0:
        print(f"\nApproved patterns written to: {STAGING_FILE}")
        print("To apply, review and append to blocked-patterns.txt:")
        print("  cat data/cve-proposed-patterns.txt >> blocked-patterns.txt")
        print("Then restart claude-code to pick up changes.")


if __name__ == "__main__":
    main()
